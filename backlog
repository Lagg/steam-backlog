#!/usr/bin/env python

"""
Copyright (c) 2014+, Anthony Garcia <anthony@lagg.me>
Distributed under the ISC License. See README
"""

import urllib2
from urllib import urlencode
import re
import operator
import argparse
import logging
import sys

import steam
from bs4 import BeautifulSoup

fractionalchars = {u'\xbc': 0.25,
                   u'\xbd': 0.50,
                   u'\xbe': 0.75
                  }

hoursurl = "http://www.howlongtobeat.com/search_main.php?t=games&page=1&sorthead=popular&sortd=Normal%20Order&plat=&detail=0"
hoursexp = re.compile(r"([0-9]+)([^0-9]*) Hours")
reviewsurl = "http://steamcommunity.com/app/{0}/reviews/?browsefilter=toprated&p=1"
reviewshoursexp = re.compile(r"(\d+\.\d+) hrs on record")

httpheaders = {
        "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:33.0) Gecko/20100101 Firefox/33.0",
        "X-Fetched-By": "Lagg's backlog helper. Forgive the scraping."
        }

def fetch_times(game):
    """ I feel like a bit of an asshole for doing this, hence the guilty header. Sorry :( """
    query = urlencode({"queryString": game["name"].encode("utf-8")})
    hours = {}

    try:
        playtimes_request = urllib2.Request(hoursurl, query, httpheaders)
        playtimes = urllib2.urlopen(playtimes_request)
    except urllib2.URLError:
        logging.error(u"HLTB connection error: {0[name]}".format(game))
        return 0

    soup = BeautifulSoup(playtimes.read())
    matches = soup.findAll(class_="gamelist_details")

    if len(matches) > 0:
        match = matches[0]
        tidbits = match.findAll("div", class_="gamelist_tidbit")
        last_tidbit_type = None

        for tidbit in tidbits:
            tidbit_match = hoursexp.search(tidbit.text)
            if tidbit_match:
                hrsrounded = float(tidbit_match.group(1))
                fractional = tidbit_match.group(2)

                if fractional:
                    hrsrounded += fractionalchars.get(fractional, 0)

                # Should never already exist, if it does there's a bug
                assert (last_tidbit_type and last_tidbit_type not in hours)

                time_accuracy = 0
                # There is apparently an accuracy rating on HLTB. Useful.
                for cls in tidbit["class"]:
                    if cls.startswith("time_"):
                        time_accuracy = int(cls[5:])
                        break

                # Convert to minutes for consistency with steam
                hours[last_tidbit_type] = {"time": hrsrounded * 60, "accuracy": time_accuracy}
            elif ' '.join(tidbit["class"]).find("time_") == -1:
                last_tidbit_type = tidbit.text

    if not hours:
        logging.warn(u"Times not found: {0[name]} ({0[appid]}) ({1:.2f} hrs)".format(game, float(game["playtime_forever"]) / 60))
    else:
        logging.debug(u"{0[name]} ({0[appid]}): {1}".format(game, ', '.join(sorted(["{0}: {1} ({2})".format(tidbit, hrs["time"] / 60, hrs["accuracy"]) for tidbit, hrs in hours.items()]))))

    return hours

def fetch_review_times(game):
    try:
        req = urllib2.Request(reviewsurl.format(game["appid"]), None, httpheaders)
        times = urllib2.urlopen(req)
    except urllib2.URLerror:
        logging.error(u"Steam review page connection error: {0[name]}".format(game))
        return 0

    soup = BeautifulSoup(times.read())
    cards = soup.findAll(class_="apphub_Card")
    hours = []

    for card in cards:
        hr = card.find(class_="hours")

        if not hr:
            continue

        hrmatch = reviewshoursexp.search(hr.text)

        if hrmatch:
            hours.append(float(hrmatch.group(1)))

    return sum(hours) / len(hours)

class progress_line(object):
    """ Could be cleaner, I know """
    def __init__(self, start, end, fmt="{0}/{1}\n"):
        self._start = start
        self._end = end
        self._lastline = None
        self._fmt = fmt

    def wipe(self):
        if not self._lastline:
            return

        sys.stderr.write("\x1b[1A")
        sys.stderr.write("\x1b[" + str(len(self._lastline)) + "D")
        sys.stderr.write("\x1b[K")
        self._lastline = None

    def inc(self, by=1):
        self.wipe()
        self._start += by
        self._lastline = self._fmt.format(self._start, self._end)
        sys.stderr.write(self._lastline)

    def dec(self, by=1):
        self.wipe()
        self._start -= by
        self._lastline = self._fmt.format(self._start, self._end)
        sys.stderr.write(self._lastline)

def longest_elem(iterable):
    if not iterable:
        return 0

    return sorted(map(len, iterable), reverse=True)[0]

def write_game_rows(stream, rows):
    """
    rows is a list of tuples, the first element
    of the tuple should be the initial game name string
    and the rest are hours
    """
    longest_name = str(longest_elem(map(operator.itemgetter(0), rows)) + 2)
    for row in rows:
        name = row[0]
        hrs = row[1:]
        line = (u"{0:<" + longest_name + "}\t").format(name) + '\t'.join(["{0:0.2f}".format(hr) for hr in hrs]) + '\n'
        stream.write(line.encode("utf-8"))

def convert_arg_line(line):
    tok = line.find('=')
    args = []

    if tok != -1:
        args = ["--" + line[:tok], line[tok + 1:]]
    else:
        args = ["--" + line]

    return map(str.strip, args)

if __name__ == "__main__":
    cmdline = argparse.ArgumentParser(description="Write out suggestions for your backlog and potential games to revisit", fromfile_prefix_chars='@')
    cmdline.add_argument("-k", "--key", help="Your API key", required=True)
    cmdline.add_argument("-u", "--user", help="Steam user (id64 or vanity)", required=True)
    cmdline.add_argument("-s", "--summary-file", default="summary.tsv", help="Filename to write the backlog order suggestions")
    cmdline.add_argument("-r", "--revisit-file", default="revisit.tsv", help="Filename to write revisit suggestions")
    cmdline.add_argument("-e", "--error-file", default="errors.log", help="Filename to write errors and warnings. Set /dev/null to suppress")
    cmdline.add_argument("-i", "--ignore", default="", help="A comma separated list of app IDs to ignore")
    cmdline.add_argument("-v", "--verbose", action="store_true", help="Verbose logging")
    cmdline.add_argument("-m", "--revisit-margin", default=25, type=int, help="Margin of error percentage. Used to see if playtimes are sufficiently different to merit revisitation.")
    cmdline.convert_arg_line_to_args = convert_arg_line
    opts = cmdline.parse_args()

    ignored_apps = [app.strip() for app in opts.ignore.split(',') if app.strip()]

    loglevel = logging.WARN

    if opts.verbose:
        loglevel = logging.DEBUG

    logging.basicConfig(filename=opts.error_file, level=loglevel, filemode="w")

    print("Logging to " + opts.error_file)

    steam.api.key.set(opts.key)

    if opts.user.isdigit():
        profile_id64 = opts.user
    else:
        profile_id64 = steam.user.vanity_url(opts.user).id64

    games = sorted(steam.api.interface("IPlayerService").GetOwnedGames(steamid=profile_id64,
                   include_appinfo=1, include_played_free_games=1)["response"]["games"],
                   key=operator.itemgetter("playtime_forever"))

    total_minutes = sum(map(operator.itemgetter("playtime_forever"), games))
    my_average_minutes = round(float(total_minutes) / len(games), 2)

    print("Our average playtime: {0:.2f} hrs".format(my_average_minutes / 60))

    # Filter out ignore apps after initial averages dump
    # Not using builtin here so that a bit of explicit logging can be done about
    # what's getting filtered
    filtered_games = []
    processed_games = []

    for game in games:
        if str(game["appid"]) in ignored_apps:
            filtered_games.append(game)
        else:
            processed_games.append(game)

    games = processed_games

    if filtered_games:
        logging.warn(u"Filtering {0} games:\n  {1}".format(len(filtered_games),
            "\n  ".join([game["name"] + " (" + str(game["appid"]) + ")" for game in sorted(filtered_games, key=operator.itemgetter("name"))])))

    print("Finding backlog times")
    backlog_games = []
    progress = progress_line(0, len(games))
    for game in games:
        progress.inc()

        if game["playtime_forever"] > 0:
            continue

        hltb_times = fetch_times(game)

        if not hltb_times:
            continue

        sorted_times = sorted(hltb_times.items(), key=lambda hrs: (hrs[1]["accuracy"], hrs[1]["time"]), reverse=True)

        time_type, projected_time = sorted_times[0]
        logging.debug(u"Using {0} time for {1[name]} with {2[accuracy]} accuracy: {3}".format(time_type, game, projected_time, projected_time["time"] / 60))

        backlog_games.append(("{0[appid]:<6}\t{0[name]}".format(game), projected_time["time"] / 60))

    print("Writing backlog summary to " + opts.summary_file)
    with open(opts.summary_file, "w") as output:
        write_game_rows(output, sorted(backlog_games, key=operator.itemgetter(1)))

    print("Determining candidates for revisitation (" + str(opts.revisit_margin) + "% margin)")
    revisit_games = []
    progress = progress_line(0, len(games))
    for game in games:
        progress.inc()
        playtime_forever = float(game["playtime_forever"])
        if "playtime_2weeks" not in game and playtime_forever > 0 and playtime_forever < my_average_minutes:
            hltb_times = fetch_times(game)

            if not hltb_times:
                continue

            sorted_times = sorted(hltb_times.items(), key=lambda hrs: (hrs[1]["accuracy"], hrs[1]["time"]), reverse=True)

            time_type, projected_time = sorted_times[0]
            difference = round(100 - (100.0 / (float(projected_time["time"]) / playtime_forever)), 2)
            projected_hours = projected_time["time"] / 60
            playtime_hours = playtime_forever / 60

            logging.debug(u"Using {0} time for {1[name]} with {2[accuracy]} accuracy: {3}".format(time_type, game, projected_time, projected_time["time"] / 60))

            if projected_time["time"] > playtime_forever:
                if difference > opts.revisit_margin:
                    revisit_games.append(("{0[appid]:<6}\t{0[name]}".format(game), playtime_hours, projected_hours))
                else:
                    logging.debug("Suppressing entry of {0[name]}: {1:.2f} / {2:.2f} difference = {3:.2f}%".format(game, playtime_hours, projected_hours, difference))

    print("Writing revisitation candidates to " + opts.revisit_file)
    with open(opts.revisit_file, "w") as revisitation_output:
        write_game_rows(revisitation_output, sorted(revisit_games, key=operator.itemgetter(2)))
