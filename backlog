#!/usr/bin/env python

"""
Copyright (c) 2014+, Anthony Garcia <anthony@lagg.me>
Distributed under the ISC License. See README
"""

import urllib2
from urllib import urlencode
import re
import operator
import argparse
import logging
import sys

import steam
from bs4 import BeautifulSoup

fractionalchars = {u'\xbc': 0.25,
                   u'\xbd': 0.50,
                   u'\xbe': 0.75
                  }

hoursurl = "http://www.howlongtobeat.com/search_main.php?t=games&page=1&sorthead=popular&sortd=Normal%20Order&plat=&detail=0"
hoursexp = re.compile(r"([0-9]+)([^0-9]*) Hours")
reviewsurl = "http://steamcommunity.com/app/{0}/reviews/?browsefilter=toprated&p=1"
reviewshoursexp = re.compile(r"(\d+\.\d+) hrs on record")

httpheaders = {
        "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:33.0) Gecko/20100101 Firefox/33.0",
        "X-Fetched-By": "Lagg's backlog helper. Forgive the scraping."
        }

def fetch_times(game):
    """ I feel like a bit of an asshole for doing this, hence the guilty header. Sorry :( """
    query = urlencode({"queryString": game["name"].encode("utf-8")})
    hours = []

    try:
        playtimes_request = urllib2.Request(hoursurl, query, httpheaders)
        playtimes = urllib2.urlopen(playtimes_request)
    except urllib2.URLError:
        logging.error(u"Failed downloading {0[name]}".format(game))
        return 0

    soup = BeautifulSoup(playtimes.read())
    matches = soup.findAll(class_="gamelist_details")

    if len(matches) > 0:
        match = matches[0]
        tidbits = match.findAll(class_="gamelist_tidbit")

        for tidbit in tidbits:
            tidbit_match = hoursexp.search(tidbit.text)
            if tidbit_match:
                hrsrounded = int(tidbit_match.group(1))
                fractional = tidbit_match.group(2)

                if fractional:
                    hrsrounded += fractionalchars.get(fractional, 0)

                # Convert to minutes for consistency with steam
                hours.append(hrsrounded * 60)

    #return sorted(hours, reverse=True)
    if hours:
        return float(sum(hours)) / len(hours)
    else:
        logging.warn(u"No times for {0[name]} ({1:.2f} hrs)".format(game, float(game["playtime_forever"]) / 60))
        return 0

def fetch_review_times(game):
    try:
        req = urllib2.Request(reviewsurl.format(game["appid"]), None, httpheaders)
        times = urllib2.urlopen(req)
    except urllib2.URLerror:
        logging.error(u"Failed fetching review page for {0[name]}".format(game))
        return 0

    soup = BeautifulSoup(times.read())
    cards = soup.findAll(class_="apphub_Card")
    hours = []

    for card in cards:
        hr = card.find(class_="hours")

        if not hr:
            continue

        hrmatch = reviewshoursexp.search(hr.text)

        if hrmatch:
            hours.append(float(hrmatch.group(1)))

    return sum(hours) / len(hours)

class progress_line(object):
    """ Could be cleaner, I know """
    def __init__(self, start, end, fmt="{0}/{1}\n"):
        self._start = start
        self._end = end
        self._lastline = None
        self._fmt = fmt

    def wipe(self):
        if not self._lastline:
            return

        sys.stderr.write("\x1b[1A")
        sys.stderr.write("\x1b[" + str(len(self._lastline)) + "D")
        sys.stderr.write("\x1b[K")
        self._lastline = None

    def inc(self, by=1):
        self.wipe()
        self._start += by
        self._lastline = self._fmt.format(self._start, self._end)
        sys.stderr.write(self._lastline)

    def dec(self, by=1):
        self.wipe()
        self._start -= by
        self._lastline = self._fmt.format(self._start, self._end)
        sys.stderr.write(self._lastline)

if __name__ == "__main__":
    cmdline = argparse.ArgumentParser(description="Write out suggestions for your backlog and potential games to revisit")
    cmdline.add_argument("-k", "--key", help="Your API key", required=True)
    cmdline.add_argument("-u", "--user", help="Steam user (id64 or vanity)", required=True)
    cmdline.add_argument("-s", "--summary-file", default="summary.tsv", help="Filename to write the backlog order suggestions")
    cmdline.add_argument("-r", "--revisit-file", default="revisit.tsv", help="Filename to write revisit suggestions")
    cmdline.add_argument("-e", "--error-file", default="errors.log", help="Filename to write errors and warnings. Set /dev/null to suppress")
    opts = cmdline.parse_args()

    logging.basicConfig(filename=opts.error_file, level=logging.WARN, filemode="w")

    print("Writing warnings and errors to " + opts.error_file)

    steam.api.key.set(opts.key)

    if opts.user.isdigit():
        profile_id64 = opts.user
    else:
        profile_id64 = steam.user.vanity_url(opts.user).id64

    games = sorted(steam.api.interface("IPlayerService").GetOwnedGames(steamid=profile_id64,
        include_appinfo=1, include_played_free_games=1)["response"]["games"],
        key=operator.itemgetter("playtime_forever"))

    total_minutes = sum(map(operator.itemgetter("playtime_forever"), games))
    my_average_minutes = round(float(total_minutes) / len(games), 2)
    max_game_name_length = sorted(map(len, map(operator.itemgetter("name"), games)), reverse=True)[0]
    column_format = u"{0:<" + str(max_game_name_length + 2) + "}\t{1:.2f}"

    print("Our average playtime: {0:.2f} hrs".format(my_average_minutes / 60))

    theirtimes = []

    print("Finding backlog times")
    progress = progress_line(0, len(games))
    for game in games:
        progress.inc()

        if game["playtime_forever"] > 0:
            continue

        hltb_times = fetch_times(game)

        if not hltb_times:
            continue

        theirtimes.append((game["name"], hltb_times))

    print("Writing backlog summary to " + opts.summary_file)
    with open(opts.summary_file, "w") as output:
        for name, minutes in sorted(theirtimes, key=operator.itemgetter(1)):
            output.write((column_format + "\n").format(name, minutes / 60).encode("utf-8"))

    print("Determining candidates for revisitation")
    revisit_games = []
    progress = progress_line(0, len(games))
    for game in games:
        progress.inc()
        playtime_forever = float(game["playtime_forever"])
        if "playtime_2weeks" not in game and playtime_forever > 0 and playtime_forever < my_average_minutes:
            hltb = fetch_times(game)
            if hltb > playtime_forever:
                revisit_candidate = {"name": game["name"], "hrs": playtime_forever / 60, "theirhrs": hltb / 60}
                revisit_games.append(revisit_candidate)

    print("Writing revisitation candidates to " + opts.revisit_file)
    with open(opts.revisit_file, "w") as revisitation_output:
        for game in sorted(revisit_games, key=operator.itemgetter("theirhrs")):
            line = (column_format + "\t{2:.2f}").format(game["name"], game["hrs"], game["theirhrs"])
            revisitation_output.write(line.encode("utf-8") + '\n')
