#!/usr/bin/env python

"""
Copyright (c) 2014+, Anthony Garcia <anthony@lagg.me>
Distributed under the ISC License. See README
"""

import operator
import argparse
import logging
import sys

import steam

import steamhltb

class progress_line(object):
    """ Could be cleaner, I know """
    def __init__(self, start, end, fmt="{0}/{1}\n"):
        self._start = start
        self._end = end
        self._lastline = None
        self._fmt = fmt

    def wipe(self):
        if not self._lastline:
            return

        sys.stderr.write("\x1b[1A")
        sys.stderr.write("\x1b[" + str(len(self._lastline)) + "D")
        sys.stderr.write("\x1b[K")
        self._lastline = None

    def inc(self, by=1):
        self.wipe()
        self._start += by
        self._lastline = self._fmt.format(self._start, self._end)
        sys.stderr.write(self._lastline)

    def dec(self, by=1):
        self.wipe()
        self._start -= by
        self._lastline = self._fmt.format(self._start, self._end)
        sys.stderr.write(self._lastline)

def longest_elem(iterable):
    if not iterable:
        return 0

    return sorted(map(len, iterable), reverse=True)[0]

def write_game_rows(stream, rows):
    """
    rows is a list of tuples, the first element
    of the tuple should be the initial game name string
    and the rest are hours
    """
    longest_name = str(longest_elem(map(operator.itemgetter(0), rows)) + 2)
    for row in rows:
        name = row[0]
        hrs = row[1:]
        line = (u"{0:<" + longest_name + "}\t").format(name) + '\t'.join(["{0:0.2f}".format(hr) for hr in hrs]) + '\n'
        stream.write(line.encode("utf-8"))

def convert_arg_line(line):
    tok = line.find('=')
    args = []

    if tok != -1:
        args = ["--" + line[:tok], line[tok + 1:]]
    else:
        args = ["--" + line]

    return map(str.strip, args)

def get_likeliest_time(game, retries=3):
    try:
        hltb_times = steamhltb.hltb(game, retries=retries).fetch()
    except steamhltb.TimesNotFound:
        return None

    if hltb_times.get("partial_match"):
        game["name"] += " (?)"

    sorted_times = sorted(hltb_times["hours"].items(), key=lambda hrs: (hrs[1]["accuracy"], hrs[1]["time"]), reverse=True)

    time_type, projected_time = sorted_times[0]
    logging.debug(u"Using {0} time for {1[name]} with {2[accuracy]} accuracy: {3}".format(time_type, game, projected_time, projected_time["time"] / 60))

    return projected_time

if __name__ == "__main__":
    cmdline = argparse.ArgumentParser(description="Write out suggestions for your backlog and potential games to revisit", fromfile_prefix_chars='@')
    cmdline.add_argument("-k", "--key", help="Your API key", required=True)
    cmdline.add_argument("-u", "--user", help="Steam user (id64 or vanity)", required=True)
    cmdline.add_argument("-s", "--summary-file", default="summary.tsv", help="Filename to write the backlog order suggestions")
    cmdline.add_argument("-r", "--revisit-file", default="revisit.tsv", help="Filename to write revisit suggestions")
    cmdline.add_argument("-e", "--error-file", default="errors.log", help="Filename to write errors and warnings. Set /dev/null to suppress")
    cmdline.add_argument("-i", "--ignore", default="", help="A comma separated list of app IDs to ignore")
    cmdline.add_argument("-v", "--verbose", action="store_true", help="Verbose logging")
    cmdline.add_argument("-m", "--revisit-margin", default=25, type=int, help="Margin of error percentage. Used to see if playtimes are sufficiently different to merit revisitation.")
    cmdline.add_argument("-n", "--name-search-retries", default=3, type=int, help="How many times to retry a search for a game name using shorter strings or a different permutation. Such games are indicated by a '(?)' next to the name.")
    cmdline.convert_arg_line_to_args = convert_arg_line
    opts = cmdline.parse_args()

    try:
        ignored_apps = [int(app.strip()) for app in opts.ignore.split(',') if app.strip()]
    except ValueError as e:
        logging.error("Bad app ID given in ignore list: " + str(e))
        raise SystemExit

    loglevel = logging.WARN

    if opts.verbose:
        loglevel = logging.DEBUG

    logging.basicConfig(filename=opts.error_file, level=loglevel, filemode="w")

    print("Logging to " + opts.error_file)

    steam.api.key.set(opts.key)

    owned_games = steamhltb.user_hours(opts.user)

    total_minutes = sum(map(operator.itemgetter("playtime_forever"), owned_games))
    my_average_minutes = round(float(total_minutes) / len(owned_games), 2)

    print("Our average playtime: {0:.2f} hrs".format(my_average_minutes / 60))

    # Filter out ignore apps after initial averages dump
    # Not using builtin here so that a bit of explicit logging can be done about
    # what's getting filtered
    filtered_games = []
    unplayed_games = []
    played_games = []

    for game in owned_games:
        if game["appid"] in ignored_apps:
            filtered_games.append(game)
        else:
            if game["playtime_forever"] > 0:
                played_games.append(game)
            else:
                unplayed_games.append(game)

    bad_appids = set(ignored_apps) - set(map(operator.itemgetter("appid"), filtered_games))

    if filtered_games:
        logging.warn(u"Filtering {0} games:\n  {1}".format(len(filtered_games),
            "\n  ".join([game["name"] + " (" + str(game["appid"]) + ")" for game in sorted(filtered_games, key=operator.itemgetter("name"))])))

    if bad_appids:
        logging.warn(u"{0} bad app IDs: {1}".format(len(bad_appids), ', '.join([str(app) for app in bad_appids])))

    print("Finding backlog times")
    backlog_games = []
    progress = progress_line(0, len(unplayed_games))
    for game in unplayed_games:
        progress.inc()

        if game["playtime_forever"] > 0:
            continue

        projected_time = get_likeliest_time(game, retries=opts.name_search_retries)

        if projected_time:
            backlog_games.append((u"{0[appid]:<6}\t{0[name]}".format(game), projected_time["time"] / 60))

    print("Writing backlog summary to " + opts.summary_file)
    with open(opts.summary_file, "w") as output:
        write_game_rows(output, sorted(backlog_games, key=operator.itemgetter(1)))

    print("Determining candidates for revisitation (" + str(opts.revisit_margin) + "% margin)")
    revisit_games = []
    progress = progress_line(0, len(played_games))
    for game in played_games:
        progress.inc()
        playtime_forever = float(game["playtime_forever"])
        if "playtime_2weeks" not in game and playtime_forever > 0 and playtime_forever < my_average_minutes:
            projected_time = get_likeliest_time(game, retries=opts.name_search_retries)

            if not projected_time:
                continue

            difference = round(100 - (100.0 / (float(projected_time["time"]) / playtime_forever)), 2)
            projected_hours = projected_time["time"] / 60
            playtime_hours = playtime_forever / 60

            if projected_time["time"] > playtime_forever:
                if difference > opts.revisit_margin:
                    revisit_games.append((u"{0[appid]:<6}\t{0[name]}".format(game), playtime_hours, projected_hours))
                else:
                    logging.debug(u"Suppressing entry of {0[name]}: {1:.2f} / {2:.2f} difference = {3:.2f}%".format(game, playtime_hours, projected_hours, difference))

    print("Writing revisitation candidates to " + opts.revisit_file)
    with open(opts.revisit_file, "w") as revisitation_output:
        write_game_rows(revisitation_output, sorted(revisit_games, key=operator.itemgetter(2)))
