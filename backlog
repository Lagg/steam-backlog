#!/usr/bin/env python

"""
Copyright (c) 2014+, Anthony Garcia <anthony@lagg.me>
Distributed under the ISC License. See README
"""

import urllib2
from urllib import urlencode
import re
import operator
import argparse
import logging
import sys

import steam
from bs4 import BeautifulSoup

fractionalchars = {u'\xbc': 0.25,
                   u'\xbd': 0.50,
                   u'\xbe': 0.75
                  }

hoursurl = "http://www.howlongtobeat.com/search_main.php?t=games&page=1&sorthead=popular&sortd=Normal%20Order&plat=&detail=0"
hoursexp = re.compile(r"([0-9]+)([^0-9]*) Hours")
reviewsurl = "http://steamcommunity.com/app/{0}/reviews/?browsefilter=toprated&p=1"
reviewshoursexp = re.compile(r"(\d+\.\d+) hrs on record")

httpheaders = {
        "User-Agent": "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:33.0) Gecko/20100101 Firefox/33.0",
        "X-Fetched-By": "Lagg's backlog helper. Forgive the scraping."
        }

def _fetch_hltb_soup(game):
    """ I feel like a bit of an asshole for doing this, hence the guilty header. Sorry :( """
    query = urlencode({"queryString": game.encode("utf-8")})

    try:
        playtimes_request = urllib2.Request(hoursurl, query, httpheaders)
        playtimes = urllib2.urlopen(playtimes_request)
        return BeautifulSoup(playtimes.read())
    except urllib2.URLError:
        logging.error(u"HLTB connection error: {0[name]}".format(game))
        return None

def fetch_times(game, max_retries=3):
    # The replace calls are to strip trademark symbols.
    querystring = game["name"].replace(u"\xae", '').replace(u"\u2122", '')

    matches = []
    hours = {}
    retries = 0

    while len(matches) == 0 and retries < max_retries:
        soup = _fetch_hltb_soup(querystring)

        if not soup:
            break

        matches = soup.findAll(class_="gamelist_details")

        if len(matches) > 0:
            if retries > 0:
                found_name_href = matches[0].select("h3 a")

                if found_name_href:
                    found_name = found_name_href[0].text
                else:
                    found_name = '?'

                logging.warn(u"{0[name]} ({0[appid]}) was found but only after shortening name to '{1}' giving '{2}'".format(game, querystring, found_name))
                game["name"] += " (?)"
            break
        else:
            retries += 1
            # This is what I call ^W simulation
            splitqs = querystring.rsplit(' ', 1)
            if len(splitqs) < 2:
                break

            querystring = splitqs[0].strip(':')

    if len(matches) > 0:
        match = matches[0]
        tidbits = match.findAll("div", class_="gamelist_tidbit")
        last_tidbit_type = None

        for tidbit in tidbits:
            tidbit_match = hoursexp.search(tidbit.text)
            if tidbit_match:
                hrsrounded = float(tidbit_match.group(1))
                fractional = tidbit_match.group(2)

                if fractional:
                    hrsrounded += fractionalchars.get(fractional, 0)

                # Should never already exist, if it does there's a bug
                assert (last_tidbit_type and last_tidbit_type not in hours)

                time_accuracy = 0
                # There is apparently an accuracy rating on HLTB. Useful.
                for cls in tidbit["class"]:
                    if cls.startswith("time_"):
                        time_accuracy = int(cls[5:])
                        break

                # Convert to minutes for consistency with steam
                hours[last_tidbit_type] = {"time": hrsrounded * 60, "accuracy": time_accuracy}
            elif ' '.join(tidbit["class"]).find("time_") == -1:
                last_tidbit_type = tidbit.text

    if not hours:
        logging.warn(u"Times not found: {0[name]} ({0[appid]}) ({1:.2f} hrs)".format(game, float(game["playtime_forever"]) / 60))
    else:
        logging.debug(u"{0[name]} ({0[appid]}): {1}".format(game, ', '.join(sorted(["{0}: {1} ({2})".format(tidbit, hrs["time"] / 60, hrs["accuracy"]) for tidbit, hrs in hours.items()]))))

    return hours

def fetch_review_times(game):
    try:
        req = urllib2.Request(reviewsurl.format(game["appid"]), None, httpheaders)
        times = urllib2.urlopen(req)
    except urllib2.URLerror:
        logging.error(u"Steam review page connection error: {0[name]}".format(game))
        return 0

    soup = BeautifulSoup(times.read())
    cards = soup.findAll(class_="apphub_Card")
    hours = []

    for card in cards:
        hr = card.find(class_="hours")

        if not hr:
            continue

        hrmatch = reviewshoursexp.search(hr.text)

        if hrmatch:
            hours.append(float(hrmatch.group(1)))

    return sum(hours) / len(hours)

class progress_line(object):
    """ Could be cleaner, I know """
    def __init__(self, start, end, fmt="{0}/{1}\n"):
        self._start = start
        self._end = end
        self._lastline = None
        self._fmt = fmt

    def wipe(self):
        if not self._lastline:
            return

        sys.stderr.write("\x1b[1A")
        sys.stderr.write("\x1b[" + str(len(self._lastline)) + "D")
        sys.stderr.write("\x1b[K")
        self._lastline = None

    def inc(self, by=1):
        self.wipe()
        self._start += by
        self._lastline = self._fmt.format(self._start, self._end)
        sys.stderr.write(self._lastline)

    def dec(self, by=1):
        self.wipe()
        self._start -= by
        self._lastline = self._fmt.format(self._start, self._end)
        sys.stderr.write(self._lastline)

def longest_elem(iterable):
    if not iterable:
        return 0

    return sorted(map(len, iterable), reverse=True)[0]

def write_game_rows(stream, rows):
    """
    rows is a list of tuples, the first element
    of the tuple should be the initial game name string
    and the rest are hours
    """
    longest_name = str(longest_elem(map(operator.itemgetter(0), rows)) + 2)
    for row in rows:
        name = row[0]
        hrs = row[1:]
        line = (u"{0:<" + longest_name + "}\t").format(name) + '\t'.join(["{0:0.2f}".format(hr) for hr in hrs]) + '\n'
        stream.write(line.encode("utf-8"))

def convert_arg_line(line):
    tok = line.find('=')
    args = []

    if tok != -1:
        args = ["--" + line[:tok], line[tok + 1:]]
    else:
        args = ["--" + line]

    return map(str.strip, args)

if __name__ == "__main__":
    cmdline = argparse.ArgumentParser(description="Write out suggestions for your backlog and potential games to revisit", fromfile_prefix_chars='@')
    cmdline.add_argument("-k", "--key", help="Your API key", required=True)
    cmdline.add_argument("-u", "--user", help="Steam user (id64 or vanity)", required=True)
    cmdline.add_argument("-s", "--summary-file", default="summary.tsv", help="Filename to write the backlog order suggestions")
    cmdline.add_argument("-r", "--revisit-file", default="revisit.tsv", help="Filename to write revisit suggestions")
    cmdline.add_argument("-e", "--error-file", default="errors.log", help="Filename to write errors and warnings. Set /dev/null to suppress")
    cmdline.add_argument("-i", "--ignore", default="", help="A comma separated list of app IDs to ignore")
    cmdline.add_argument("-v", "--verbose", action="store_true", help="Verbose logging")
    cmdline.add_argument("-m", "--revisit-margin", default=25, type=int, help="Margin of error percentage. Used to see if playtimes are sufficiently different to merit revisitation.")
    cmdline.add_argument("-n", "--name-search-retries", default=3, type=int, help="How many times to retry a search for a game name using shorter strings or a different permutation. Such games are indicated by a '(?)' next to the name.")
    cmdline.convert_arg_line_to_args = convert_arg_line
    opts = cmdline.parse_args()

    try:
        ignored_apps = [int(app.strip()) for app in opts.ignore.split(',') if app.strip()]
    except ValueError as e:
        logging.error("Bad app ID given in ignore list: " + str(e))
        raise SystemExit

    loglevel = logging.WARN

    if opts.verbose:
        loglevel = logging.DEBUG

    logging.basicConfig(filename=opts.error_file, level=loglevel, filemode="w")

    print("Logging to " + opts.error_file)

    steam.api.key.set(opts.key)

    if opts.user.isdigit():
        profile_id64 = opts.user
    else:
        profile_id64 = steam.user.vanity_url(opts.user).id64

    owned_games = sorted(steam.api.interface("IPlayerService").GetOwnedGames(steamid=profile_id64,
                         include_appinfo=1, include_played_free_games=1)["response"]["games"],
                         key=operator.itemgetter("playtime_forever"))

    total_minutes = sum(map(operator.itemgetter("playtime_forever"), owned_games))
    my_average_minutes = round(float(total_minutes) / len(owned_games), 2)

    print("Our average playtime: {0:.2f} hrs".format(my_average_minutes / 60))

    # Filter out ignore apps after initial averages dump
    # Not using builtin here so that a bit of explicit logging can be done about
    # what's getting filtered
    filtered_games = []
    unplayed_games = []
    played_games = []

    for game in owned_games:
        if game["appid"] in ignored_apps:
            filtered_games.append(game)
        else:
            if game["playtime_forever"] > 0:
                played_games.append(game)
            else:
                unplayed_games.append(game)

    bad_appids = set(ignored_apps) - set(map(operator.itemgetter("appid"), filtered_games))

    if filtered_games:
        logging.warn(u"Filtering {0} games:\n  {1}".format(len(filtered_games),
            "\n  ".join([game["name"] + " (" + str(game["appid"]) + ")" for game in sorted(filtered_games, key=operator.itemgetter("name"))])))

    if bad_appids:
        logging.warn(u"{0} bad app IDs: {1}".format(len(bad_appids), ', '.join([str(app) for app in bad_appids])))

    print("Finding backlog times")
    backlog_games = []
    progress = progress_line(0, len(unplayed_games))
    for game in unplayed_games:
        progress.inc()

        if game["playtime_forever"] > 0:
            continue

        hltb_times = fetch_times(game, max_retries=opts.name_search_retries)

        if not hltb_times:
            continue

        sorted_times = sorted(hltb_times.items(), key=lambda hrs: (hrs[1]["accuracy"], hrs[1]["time"]), reverse=True)

        time_type, projected_time = sorted_times[0]
        logging.debug(u"Using {0} time for {1[name]} with {2[accuracy]} accuracy: {3}".format(time_type, game, projected_time, projected_time["time"] / 60))

        backlog_games.append((u"{0[appid]:<6}\t{0[name]}".format(game), projected_time["time"] / 60))

    print("Writing backlog summary to " + opts.summary_file)
    with open(opts.summary_file, "w") as output:
        write_game_rows(output, sorted(backlog_games, key=operator.itemgetter(1)))

    print("Determining candidates for revisitation (" + str(opts.revisit_margin) + "% margin)")
    revisit_games = []
    progress = progress_line(0, len(played_games))
    for game in played_games:
        progress.inc()
        playtime_forever = float(game["playtime_forever"])
        if "playtime_2weeks" not in game and playtime_forever > 0 and playtime_forever < my_average_minutes:
            hltb_times = fetch_times(game, max_retries=opts.name_search_retries)

            if not hltb_times:
                continue

            sorted_times = sorted(hltb_times.items(), key=lambda hrs: (hrs[1]["accuracy"], hrs[1]["time"]), reverse=True)

            time_type, projected_time = sorted_times[0]
            difference = round(100 - (100.0 / (float(projected_time["time"]) / playtime_forever)), 2)
            projected_hours = projected_time["time"] / 60
            playtime_hours = playtime_forever / 60

            logging.debug(u"Using {0} time for {1[name]} with {2[accuracy]} accuracy: {3}".format(time_type, game, projected_time, projected_time["time"] / 60))

            if projected_time["time"] > playtime_forever:
                if difference > opts.revisit_margin:
                    revisit_games.append((u"{0[appid]:<6}\t{0[name]}".format(game), playtime_hours, projected_hours))
                else:
                    logging.debug(u"Suppressing entry of {0[name]}: {1:.2f} / {2:.2f} difference = {3:.2f}%".format(game, playtime_hours, projected_hours, difference))

    print("Writing revisitation candidates to " + opts.revisit_file)
    with open(opts.revisit_file, "w") as revisitation_output:
        write_game_rows(revisitation_output, sorted(revisit_games, key=operator.itemgetter(2)))
